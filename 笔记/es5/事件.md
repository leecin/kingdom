# 事件
> javascript和html之间的交互就是通过`事件`实现的。可见事件在js编程中的地位。
事件也分三个层级：DOM0、DOM2、DOM3

## 事件的一些概念
- 事件流
1. IE事件流，属于冒泡模式
2. W3C事件流，也叫标准事件流，属于捕获模式

## 事件兼容
```ts
// 获取事件触发的对象
IE: event.srcElement
W3: event.target
var target = event.target || event.srcElement // 兼容写法

// 阻止冒泡
IE: event.cancelBubble = true
W3: event.stopPropagation()

// 阻止默认事件
IE: event.returnFalse = true
W3: event.preventDefault()

// 事件监听，当对应事件被触发时，对应的callback就会执行
// mode: true:捕获，false:冒泡；默认冒泡方式
IE: NODE.attachEvent(eventName, callback)
W3: NODE.addEventListener(eventName, callback, mode)

// 移除事件监听
IE: NODE.detatchEvent(eventName, callback)
W3: NODE.removeEventListener(eventName, callback, mode)
```

## 封装兼容事件库
> 为了统一标准事件和IE事件写法，这样在业务中就可以直接使用，无需过多考虑浏览器的事件兼容问题
另外，IE事件流中只有冒泡模式，没有捕获模式
```ts
class EventUtil = {
  addEventListener(el, type, cb, mode=false) {
    if (el.addEventListener) {
      el.addEventListener(type, cb, mode);
    } else if (el.attachEvent) {
      el.attachEvent(type, cb, false); // IE只有冒泡模式
    } else {
      el['on'+type] = cb;
    }
  }

  removeEventListener(el, type, cb, mode=false) {
    if (el.removeEventListener) {
      el.removeEventListener(type, cb, mode);
    } else if (el.attachEvent) {
      el.detachEvent(type, cb, false); // IE只有冒泡模式
    } else {
      el['on'+type] = null;
    }
  }

  getEvent(event) {
    return event || window.event; 
  }

  getTarget(event) {
    return event.target || event.srcElement;
  }

  preventDefault(event) {
    if (event.preventDefault) {
      event.preventDefault();
    } else {
      event.returnFalse = true;
    }
  }

  stopPropagation(event) {
    if (event.stopPropagation) {
      event.stopPropagation();
    } else {
      event.cancelBubble = true;
    }
  }
}
```

## DOM中的事件对象
DOM中的事件写法：`on + 事件类型(小写)`
```ts
<input type="button" onclick="alert(23)" />
```

