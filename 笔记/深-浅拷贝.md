# 浅拷贝
```ts
function shallowCopy(obj) {
  if (typeof obj !== 'object') return;
}

```

# 深拷贝
1. 判断是否是对象类型
2. 区分是数组还是对象
3. 遍历对象中的每一项，除掉继承来的属性
4. 判断是否子元素也是对象类型，如果是接着递归
在执行之前四步之前需要知道：
- [x] Object.hasOwnProperty(property)，判断Object中是否含有`property`属性
- [x] for (let k in obj) {}，`in`操作会遍历继承而来的属性

```ts
function deepCopy(obj) {
  if (typeof obj !== 'object') return;
  let newObj = obj instanceof Array ? [] : {}
  for (let k in obj) {
    if (!Object.hasOwnProperty(k)) { // obj.hasOwnProperty(k)
      newObj[k] = typeof newObj[k] === 'object' ? deepCopy(newObj[k]) : obj[k]
    }
  }
  return newObj
}
```

## JSON.parse和JSON.stringify实现深拷贝
> 该方法不是万能的！在以下3个方面无能为力

- [x] 对象中包含正则表达式；`/^hello/`
- [x] 对象中包含函数：`function() {}`
- [x] 对象中包含undefined：`undefined`，在obj中会被忽略，在数组中会被转成null
```ts
function copyObj(obj) {
  return JSON.parse(JSON.stringify(obj));
}

// 测试
var obj = {
  reg: /^(?:split|reverse)$/,
  fun: function() {},
  und: undefined,
  age: 23
}
var ret = copyObj(obj)
console.log(obj) // {rgex: /^\s*/g, u: undefined, fn: ƒ, desc: "去掉字符串左侧空白字符正则"}
console.log(ret) // { age: 23, reg: {} }
```
TODO：需要研究一下JSON.stringify底层实现，知道为什么有些情况下不能使用












