### 防抖原理
> 不管事件触发多少次，我只在事件停止触发 n 秒后执行。
就是说这里需要考虑以下两种情况：
1.事件触发`n`秒后，在这`n`秒内不再触发，则`n`秒后立即执行
2.事件触发`n`秒后，在这`n`秒内又触发了事件，则以新触发事件的时间为准，在此时间`n`秒后执行

### 为什么使用防抖
> 解决浏览器性能问题
因为同一事件频繁触发，如果浏览器处理不过来，页面就会出现卡顿，影响用户体验，
所以性能优化对于前端来讲，至关重要。

### 如何实现防抖
1.基础实现
```js
function debounce (fn, delay) {
  var timeout
  return function() {
    console.log(this)
    clearTimeout(timeout) // 保证指定时间内只执行一次
    timeout = setTimeout(fn, delay)
  }
}
```
可以这样使用：1.传入待执行的函数，2.传入执行函数的延迟时间
```js
function fn () {
  console.log(this) // window对象
  console.log('执行了')
}
window.document.addEventListener('mousemove', debounce(fn, 500))
```
可以发现上面的this指向全局对象window，能否改变这个this的指向？
可能有些场景，我们并不希望this指向window

2.改变this指向
```js
function debounce(fn, delay) {
  var timeout
  var cxt = this
  return function() {
    clearTimeout(timeout)
    var fn = fn.apply(ctx)
    timeout = setTimeout(fn, delay)
  }
}
```