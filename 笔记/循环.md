# 循环
- [x] for类
1. `for`
2. `for..in`
3. `for..of`
4. `forEach`

- [x] 其他
1. `while`
2. `do..while`
3. `map`
4. `reduce`
5. `filter`
6. `some`
7. `every`
8. `find`
9. `findIndex`
---
## for循环
特点：
  1. 可以随时中断循环：continue和break
```ts
var arr = [false, true]
for (var i = 0, len = arr.length; i < len; i++) {
  if (arr[i]) break
}
```

## for..in循环
特点：
  1. 循环对象的key，es5标准
  2. 遍历对象`自有的`、`继承的`、**`可枚举的`**、`非symbol`的属性
  3. 不应用于循环数组
  4. 可中断循环：continue，break

`数组索引`只是具有整数类型的可枚举属性，所以理论上是可以循环数组的。但是
不建议用来循环数组，是因为`for..in`不能保证循环后的索引顺序与循环前一致（因为迭代的顺序依赖于执行环境）
```ts
var person = { name: 'zs', age: 33 }

// 自有属性
var Person = function() {
  this.addr = 'sz'
}

// p1继承至person
Person.prototype = person
var p1 = new Person()

// 打印自有的、继承的、可枚举的、非symbol属性
for (var k in p1) {
  console.log(k)  // addr, name, age
}
```
如何过滤掉继承的属性？有这三种方式：
  1. `hasOwnProperty`，判断目标属性是否是自身的属性
  2. `getOwnPropertyNames`，获取自身所有属性
  3. `propertyIsEnumerable`，判断是否是可枚举熟悉
```ts
// instance.hasOwnProperty(property)
for (var k in obj) {
  if (obj.hasOwnProperty(k)) {
    // 这里都是自身可枚举属性...
  }
}

// Object.getOwnPropertyNames(obj)
for (var k in Object.getOwnPropertyNames(obj)) {
  // 这里都是自身可枚举属性...
}

// instance.propertyIsEnumerable(property)
for (var k in obj) {
  if (obj.propertyIsEnumerable(k)) {
    // 这里都是自身可枚举属性...
  }
}
```

## for..of循环
特点：
  1. 循环对象的value，es6标准
  2. 循环中断：`continue`，`break`
  3. 循环可迭代对象(`Array`, `Map`, `Set`, `String`, `arguments`对象等)
  4. 只遍历自身属性值(不包括自定义属性，继承属性)

语法：
```ts
for (variable of obj) {}
```
```ts
var person = [2, 4, 6]
person.name = 'lj' // 自定义属性

var Person = function() {
  this.age = 33
}
Person.prototype = person
var p1 = new Person()

for (var v of person) {
  console.log(v) // 2, 4, 6
}
```

## for..in和for..of区别
- [ ] `for..in`
  1. 循环key，es5标准
  2. 遍历自定义属性
- [ ] `for..of`
  1. 循环value，es6标准
  2. 搭配`Object.keys()`循环对象
```ts
for (let k in obj) {}
for (let k of Object.keys(obj)) {}
```

## forEach循环
如果使用箭头函数表达式来传入函数参数，thisArg 参数会被忽略，因为箭头函数在词法上绑定了 this 值
特点：
  1. 不能中断循环
  2. 不可链式调用(因为callback总是返回`undefined`)
  3. 不改变调用它的对象
  4. 对数组的每一项执行一次callback
  5. 集合迭代器，循环DOM节点(NodeList)

语法：
```ts
// 当callback是箭头函数时，thisArg会被忽略
arr.forEach(callback[, thisArg])
callback(curVal, index, arr)
```
```ts
// 数组循环过程中，动态改变数组的元素项，则会跳过某个元素
[1, 2, 3, 4].forEach((item, idx, ary) => {
  // 跳过2后面的元素3
  console.log(item) // 1, 2, 4
  if (item === 2) {
    ary.shift()
  }
})

// forEach的垫片
if (!Array.prototype.forEach) {
  Array.prototype.forEach = function(callback, thisArg) {
    // 保存this变量和key
    var t, len, o;
    if (typeof this !== 'object') {
      throw new Error('this is not an object type');
    }

    // 确保是数组，这个this是调用forEach的对象
    o = Object(this)
    len = o.length

    // callback是否是函数
    if (typeof callback !== 'function') {
      throw new TypeErro(callback + 'is not a function');
    }

    // 是否传入了this，如果传入this，则替换原来的
    if (arguments.length > 1) {
      t = thisArg
    }

    var k = 0
    while(k < len) {
      // key必须为索引
      if (k in o) {
        callback.call(o, k, o[k], t)
      }
      k++
    }
  }
}
```

